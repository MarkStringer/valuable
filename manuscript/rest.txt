##The Good Enough Parent
There's an idea in Freud's writing - the pleasure principle.  The idea is that when we're babies we go through a period where whatever we need is given to us.  When we're hungry we're fed, when we've soiled ourselves, we're cleaned, when we're tired we can go to sleep, when we're awake, we can wake up (even if it's the middle of the night). And this period stops.  For the rest of our lives, we don't always get what we want, when we want and this is very upsetting. I think most of us never get over it.

When I was explaining this to friend of mine Tim Diggins, he pointed me in the direction of D.W. Winnicott and the concept of the "Good Enough Parent." The idea, I think of the "Good Enough Parent" is one that provides enough support for the child to deal with the brutal and uncertain nature of the world, but at the same time, doesn't hide the child from it's brutal and uncertain nature.

The image that came into my mind just then was of that day when the parent decides that they're going to take the stabilisers (trainer wheels) off of the bike and let the child ride without them. There's a kind of memory of this - so clichéd that you might doubt that it actually happened to you, of the parent standing behind the child and holding the saddle and moving the child forward saying to the child "peddle, peddle, I'm holding you." And of course, there's that amazing moment when the child is peddling and moving forward and suddenly realises that their parent can't be holding them. Of course, there's no guarantee that they're not going to fall off immediately after that.  But for a moment there, they were doing it, they were riding the bike, all by them selves.

I remember crying a lot when I learned to ride a bike (it only took an afternoon).  But I also remember that amazing feeling of *balance* of the bike magically moving in the right direction under my control. And I remember my dad being endlessly patient as I was trying to get the hang of it probably saying something like "It's all right, just have a go, I'm holding you, you can do it", and I remember my uncle being impatient and taking a much more "why are you crying? Don't be such a baby." attitude.

I'm wondering if that was what was going on with George, I was being the "Bad Cop" parent with him. "Projects always take longer than you think, they always cost more than you think. There are no guarantees in software development and I'm definitely not giving you one.  If you want a guarantee, buy a toaster." 

And George's reaction was to throw his rattle out of his pram (by throwing the phone down).  Twice.

We could have both probably handled it better.  We were very much in the "storming" phase of our relationship. I suppose it might have been that I'd already got some awareness that George was aggressively and successfully bullying other people in the organisation that made me reluctant to engage.

##The Wreck of An Idea
"Every novel is the wreck of an idea" - Iris Murdoch
I didn't get this quote first hand.  I saw a documentary on another novelist - Ian Rankin - and he used it as a source of inspiration.

But I think it's very relevant to software development, project management.  It's the job of the leaders (sociopaths) to have ideas, or to steal ideas.  And it's the job of the leaders (sociopaths) to polish those ideas so that they shine, to turn them into a Fata Morgana an mirage on the horizon that people are prepared to put money into heading towards.  And it's the job of the leaders (sociopaths) to obscure the risks and potential costs of setting sail towards this Fata Morgana.

But of course, once the ship does set sail, stuff goes "wrong". Wrong is one way of thinking about it.  Another way of thinking about it is that stuff that happens in the real world, rather than in the dream world happens. If this is a ship that's setting out to discover distant lands, the crew will get ill, the ship will be becalmed, the short cut to India will turn out to be blocked by a bloody great continent. If this is a software development project, all the real problems that are associated with actually having to write software and actually make it available to be used will present themselves. In software development, these are things that often seem embarrassingly ordinary, mundane (from the Latin mundus - "meaning of the world"). The team can't get into the building because they don't have building passes, the wifi doesn't work.

Of course there can be other, more fundamental problems.  The dream, the idea, the Fata Morgana, might sound great.  It might roll of the tongue, it's clearly motivated somebody to release money to make it happen.  But the detail isn't there.  Or when you look at the detail, you see that there are inherent contractions. Or when you look for the detail, you find that there are competing factions who will provide you with the detail. Or when you look for the detail you find that there are factions that kept quite while the project was being "green lit" but who are sworn to make sure it fails.

Yes, there are some very tricky moments in actually getting a ship to set sail *at all* and there some further tricky moments the minute it leaves the harbour.

And these moments can obviously be very difficult for the leader (sociopath) who persuaded everybody that it was a good idea to have a project that would set off in the direction of this Fata Morgana. And so of course, the leader (sociopath) will try to obscure these difficulties as much as he can and keep burnishing the Fata Morgana to distract from what's actually happening.  But surely, a clever leader (sociopath) would also be doing two other things.

Firstly, he'd be making sure that the team got what they needed to at least have a chance to get where they're going. He'd be paying close attention to what the team is saying that they actually *need* to get things done. Because a smart leader (sociopath) understands that this is the only way anything is actually going to get done.

Secondly he'd be looking at what the team were actually producing to see if there was anything he could celebrate, publicise, burnish.

But maybe the team, and the project manager, Scrum Master should recognise that looking at what is actually produced - the wreck of the idea is always going to be a dangerous, embarrassing and worrying experience for the person who has been making sure that everybody was looking at the Fata Morgana.

Maybe one of the weaknesses of an Agile approach is the false promise that's held out by the phrase "working software". I think a lot of people who don't know about software imagine not just working, but shrink-wrapped, off-the-shelf, fully functional software. Also, when people imagine working software, most of their thoughts are about the UI and they also can't imagine what the value is of software that only does a tiny part of what the whole thing will need to do in order to be useful and valuable to them.

So showing working software, especially early on in the process, can be an upsetting experience for product owners and other people who want the software.  If you're a leader (sociopath) and you've been polishing a vison (Fata Morgana) and overstating the benefits that will accrue for realising that vision, when you get to see some of the initial products of the project that is supposed to realise that vision, one of the first reactions you might have is to want to conceal it.  Never is working software more of a wreck of an idea than in those first few iterations.

But of course, this wreck of an idea has some massive advantages over the idea.  The wreck of an idea actually exists. The wreck of an idea can actually help with business.  The wreck of an idea can actually show products to customers, take their orders, take their credit card details and make money.

Still, the seductive power of the vision at the beginning of the project can be so powerful that the people who have achieved this thing that actually does work in the real world, and either makes money, or makes people's lives better, can't see it. I've been involved with projects where software has been delivered and the users have fallen on it like a starving crowd. And like a starving crowd, they clamour for more, more features, more performance, broader user base. But when you talk to the people who were involved in the project, they can't see its success, all they can see are the ways in which the project "failed" relative to the initial vision.  It took too long (relative to some initial arbitrary estimate of how long it would take).  It's not performing as well as it should (relative to some arbitrary estimate of how well it should perform - and because it is being heavily used.

But actually, projects like that are successful, compared with project where the focus never moves away from the idea.

##The World According to Saddam Hussein or Does your Project Needs a Black Box?
>What is politics? Politics is when you say you are going to do one thing while intending to do another. Then you neither do what you said or what you intended.

Quoted in the Guardian 19/03/2003

It seems to me that Saddam is right.  In any project, just like in politics, there are these three descriptions, three ways of looking at what will happen:

###1. What we *say* we're going to do 
This involves the vision – the Fata Morgana.  The clean, simple idea capable of motivating large numbers of people. Often the clean simple idea will have in it a concept involving either "same" or "all". For example "merge all the social security payment systems into one single payment system." Or "make the process of applying for a loan completely (all) self-service".

What we *say* we're going to do is often also included in some kind of bid proposal which accompanies work and is therefore also connected with money.  This is possibly what makes writing bid proposals so hard, because they have to combine the vision that motivates the customer to part with their money with some kind of realistic description of what's actually going to be done. Having been involved in this process myself, I've come to realise that this is from easy.

###2. What we intend to do
Bizarrely, in many projects, this isn't clear.  We know at the start of the project that the project isn't possible in the timescales and costs that have been promised.  If we think about it for one second, we realise that the requirements for the project can't be realised because they're simply too vague.

In most projects that we start, in our heart of hearts, we know that the reality is going to be far messier and far more expensive and time-consuming for the client that we care to admit. And one the main reasons for this is that if we did admit how messy, risky and time-consuming a project would be, this would simply scare our clients away. When looking at competing bids, the client would simply go with one that looked clear, and simple.

###3. Neither what you said, nor what you intended.
In most cases, what actually happens on a project is neither what you said you were going to do, possibly in some kind of bid, nor what you intended. Curiously, what actually happens; how projects actually turn out; how long they *actually* take; how much they *actually* cost; is something that is hardly ever discussed. 

You might think that people who are involved with software development, or people who pay for software development, would be absolutely fascinated with how software development projects had gone wrong in the past. You might think that the people with money who really want their projects to go well, would be paying fortunes to investigate why previous projects hadn't gone well - think of all the money that goes into airplane crash investigations. And then all the effort that goes into redesigning any parts that fail or changing any safety procedures that seem to be lacking.

Isn't that strange?  That so few people want to look at the projects that have *actually* happened, nobody wants to look at how long things *actually* took compared to how long they were estimated to take. It feels wrong to even mention it, like talking about death, or impotence.

I once worked on a project for a government department.  It was a system that implemented a particular bit of international legislation that re-negotiated every seven years. That meant that every seven years, new software had to be developed to implement the legislation. If the software didn't implement the legislation properly, the government would be fined for every day that it didn't manage to implement the legislation by the international body that it was signatory.  There was big money at stake.

The last two attempts at developing software to meet the legislation had been judged to be a failure. Although, bearing in mind the way that any actual, working software is treated as "The Wreck of an Idea" we might wonder to what degree they had actually been failures when they finally, late and massively over-budget, did start working, collecting data and making payments. 

I do know that one of the "failures" was so bad, that a special sub-committee of the house of commons was formed to hear from the senior officers and I think I heard that an amendment was made to a piece of legislation to make sure that the senior officers in the department who were responsible for the project didn't get their bonuses. Now also sorts of bad stuff can happen, and senior civil servants can deal with it without breaking a sweat.  But when committees and acts of parliament are being rolled out to make sure that they don't get their bonuses? That's pretty serious.

I don't think I ever heard or saw any discussion within this department of what had gone wrong on the previous projects, or any listing of what might be done differently this time.
 
Another weird thing about this is that at the end of every project, certainly every software development project, where the software is actually being *used* you have working software. And if you have working software (if it's going to work for very long) you must also have the *code* for that working software. So people who know about software could go and look at it. There could be such a thing as forensic software architects and project crash investigators.

In some ways, I wish I didn't have to say that you need a "black box" for your projects. But I've seen it happen on so many projects, that I think, in reality you do. Why do you need a black box? Because at some point, because of the way most projects are funded and initiated, you're going to have to negotiate after a catastrophe. The catastrophe comes about when the gap between what's promised in the vision and what's being delivered - what has actually happened, just becomes untenable.

Although there is actually a way of avoiding the need to look back, the need for a black box, the need for forensic software engineers, by focusing all the way through the project on working software.  There is a way to avoid the project crashing, and that's by focusing all the way through the project on improving the "Wreck of the idea" rather than focusing on the idea.

##Working Software
>"Any sufficiently advanced technology is indistinguishable from magic"
Arthur C. Clarke

The value in the Agile manifesto is 
>"Working Software over detailed documentation."

But working software is perhaps the aspect of Agile thinking which isn't easily contrasted with other, more traditional aspects of project management, or maybe could be contrasted with all of them. Working software over processes and tools? Yes.  Working software over contract negotiation? Yes. Working software over following a plan? Absolutely.

Working software, working software, working software. But the real value of working software isn't really in opposition to any of these things.  The real value of working software is in opposition to *not* working software.  To its absence. Working software is the only thing which can deliver value for the organisation.

But that value isn't often explained correctly to product owners and senior stakeholders. What exactly is the value of working software?

One way to think about working software is that it is a series of tests. Working software can test that a proposed technical solution involving an architecture and collection of packages and languages is feasible.  Working software can also test that the organisation actually has the capability to deliver code into a live, or like-live environment. Working software can test the quality of the understanding all along the chain between the people who need to the software to do something, the people who capture that need, and the people who implement that need. Working software tests all these things.  But working software can itself also be tested.  Working software can be tested on the ultimate beginning and end of the software development process, who is often forgotten - the user. Working software can be performance tested, accessibility tested and penetration tested. And in doing so, working software tests all of this testing.

Working software is powerful stuff. Powerful, and dangerous, threatening. Dangerous to what? Threatening to whom?

###Working software is a threat to the dream
The vision, the Fata Morgana - the deceiving mirage of the project. Once people see the working software, it may become obvious that the dream and the vision are just that, dreams and visions. Or it may become obvious that the vision *is* realisable, but at far greater cost of money and time than had ever been discussed.

###Working software is a threat to the development team
At first, working software is very slow to emerge from the development team, and when it does, it's functionality is often limited and bug-ridden. This can be very embarrassing for the development team and very worrying for the product owner, not least because development teams are enormously expensive.

###Working software is a threat to the architects
Attempts at creating working software can highlight flaws in a proposed architecture and technology stack. Attempts at creating working software can highlight invalid assumptions (the most dramatic example of this that I've ever seen was design for a bank that relied on a transactional database that simply didn't exist).

###Working software is threat to the release team
The release team might not be ready to release anything. They may not have any environments that can be configured for release. They may simply not have the expertise to release the software. The release team, may well have anticipated that they would have the lifetime of the development project - maybe six to eighteen months to hire the people they needed and put the right facilities in place.

###Working software *might* be a threat to the users
New software threatens jobs. Often the value calculation for new software is given in terms of the full-time employees that can be let go once the software has been rolled out. New software is often an attempt to automate tasks that were previously done by humans, and often, those people who will be replaced are the ones who are asked to evaluate it.

Even if the users won't be replaced, new software may require them to learn new skills, work in different ways to change.

###Working software is a threat to everyone involved in the project
Working software is a threat to every individual group within an organisation. In many big commercial and government projects, many of the groups that are threatened work for different companies and so the threat is even more pronounced and the temptation to put off the demonstration of working software in a live, or like-live environment is even more pronounced.

###(When it's done right) working software is a threat to the whole organisation
I'm often asked when I'm coaching, especially when I'm coaching one-to-one, where to look for good jobs in Agile. The answer that I normally give is to look for organisations that really need the software, where the benefit of having the software and the need to have the software is obvious to everyone.

But even when it is obvious that software is needed by an organisation, or it is obvious that software would give enormous value to an organisation, that does not mean that actually having working software that people can look at, and even use, isn't a threat to people in the organisation. But collectively, the only way that the organisation can benefit from the software is if it works.

The value and threat of working software is something that simply isn't discussed. And it is very easy, even in an organisation where everyone is agreed that the organisation needs the software and that the software will be valuable to the organisation to have no one who is championing getting working software out of the development environment. Product owners will probably understand the value of getting software to the stage where it can be demonstrated, but will rarely understand the value, or the effort and difficulty involved in getting the software from the point where it can be demonstrated in a development or test environment to the point where it can actually be released.

On many projects, Scrum Masters are the people who most understand the value of an Agile approach to software development and understand the value of working software. but often they aren't in a position to make working software any more likely to happen. They don't have control, or sometimes even influence over things that effect the rate of delivery of working software but happen outside of the development team, such as non-functional testing and operations and release.

Lean is surely supposed to focus on this problem. Surely the main insight of lean is that the value of the individual roles and processes needs to be subsumed to the value of their being smooth flow through the whole process. And maybe this works when the value of what comes out of the end of the process is known (e.g. a car). But in software development, the value of the software that is produced at the end of the process is uncertain. And there are all sorts of other values along the process that can be locally optimised, and are possibly in opposition.

It's in the interests of the non-functional testers to "wait until the software is finished" before they do their tests because this puts off revealing that they have neither tests nor infrastructure on which to run the tests. Although of course, the best way to make sure that any application is non-functionally tested is to do that testing repeatedly on incrementally releases of working software.

It's in the interests of the operations and release teams to avoid having working software on a live or like-live environment because that makes their job far harder. Although of course the best way of making sure that the live and like-live release environments are properly maintained and fit-for-purpose is to actually use them.

It's definitely in the interests of those people who are tasked with security for the project to put off having the project in live, or like-live as long as possible. Although the best way of testing the security of an application is to actually start to use is and test it in a small way as soon as *some* functionality is available.

There are so many interests that are orthogonal to the project, that, in some ways, it's surprising that *any* software makes it to release in live at all. This orthogonality, this pointing in the wrong direction, this disinterest in the project doing what it absolutely has to do to achieve its stated goals - produce working software - gets even worse when all the people who are involved in a project are working for different companies and different organisations.

So what is to be done? To be totally honest, I think a lot of this is still to be worked out. I think that one of the most successful parts of Scrum is the idea of a Scrum Master - a role which is dedicated to facilitating the team and facilitating the Scrum Process. 
Another thing that the Scrum Master (or seems to end up doing) is publicising and making visible the problems that the team are encountering that they can't deal with themselves. These are problems where it is obvious, that there are no local optimisations.

Thinking about software development in terms of working software does lead you back to thinking about all of the methods and approaches that have been suggested by manufacturing in Japan. Visualise the work in progress. Limit the work in progress. Apply the ideas from Eli Goldratt's "The Goal" around identifying the constraint in the system and "breaking it" (i.e. stopping it being the constraint). But I think it is vitally important to understand this difference, that in manufacturing the value of the thing that is being manufactured is, to some degree understood.  Whereas, in software development, the value of what is being developed isn't understood.

One insight that I gained from my colleague Marc Burgauer (who I think got it from Peter Drucker) is that management is about managing the work. The ultimate product of work in software development is value to the organisation, but because the value of the software to the organisation is unknown, the only way to assess that value is to get *something* working and then incrementally increase its functionality until its value to the organisation starts to make sense.

Managing the work in software development means first of all working to improve visibility. If progress is going to be reported, it should be reported in terms of working software delivered, either to a live, or in very special circumstances, where making live software available even to a tiny number of users would be problematic, a like-live environment.

Managing the work in software development means seeing the development process from the point of view of the work. Who does the work visit? What local processes does it undergo? Do those processes add value? Where does work wait a long time? Where is there a backlog of work?

In my experience, Scrum is extremely effective in getting an iterative, incremental, empirical process going within an organisation and in creating pull on the organisation to produce requirements that can be turned into software, that could be valuable to the organisation. There are however ways in which Scrum is not so successful.  Scrum is, no so good at communicating back to the organisation, what is going on in the Scrum team and what progress is being made. Scrum also often fails to "push" working software into live environments where it has a chance of being valuable to the organisation.

##What do "Agile Programmes" actually look like?
When I run the Agile foundation training course, one of the questions that I ask them is how many Agile projects they have been on, A lot of the time, when people answer the question, they will say something like "some aspects of this project were Agile, but it wasn't *fully* Agile." Because of course, what they're talking about is Saddam Hussein's third category - what *actually* happens. There is even a name for this kind of methodology - "ScrumBut" as in "we're using Scrum but we're not having stand-ups" or "We're using Scrum but we don't have a product owner." Or "we're doing Scrum but we don't have showcases, or retrospectives, or working code at the end of every sprint."

Scrum has a lot of useful ideas in it, and that is really, putting it mildly. Scrum it also has a lot of aspirations which are extremely difficult to satisfy. Having "potentially shippable code" at the end of every sprint is extremely difficult when there are a whole separate set of people who insist that that code goes through further non-functional testing. It is even more difficult when there is an insistence that this kind of testing has to be done before the code can be released, but there are no tests and no testers.

Requirements need to be gathered and refined outside of the sprint.

In my experience, in any real-life large-scale development project, it is perfectly possible to have *any* of the things that you might regard as necessary to the success of the project, and absolutely essential to software development be missing. For example, I've worked on several programmes where one or more of the following things were missing: developers, computers, network access, access to the building, access to a product owner, access to subject matter experts, access to a release environment, access to a development environment.

And it's far from unusual to have programme managers who are telling you that the "aggressive" timescales for the programme have to be met whilst at the same time explaining that the performance testing environment won't be available until a week before the release date, because having it available earlier would be a "waste of money."

It's hard to incorporate "ility" testing into your sprint if you have no idea what the "ility" tests will be, or who will be doing them.  It's difficult to claim that your code is "potentially shippable" if there is no environment on which to deploy it.

It's also probably worth mentioning that not everybody working in these programmes is a "motivated individual". Or if they *are* motivated, they're not necessarily motivated by the thought of doing a good job, or making sure that the project succeeds by delivering working software which is valuable to the customer. 

On large projects, both commercial and in government, there can often be more than half a dozen companies who are supplying people.  It's very difficult to align the interests of all these companies, so that they're all focused on delivering working software. The clients in these kind of "multi-vendor" environments are often of the opinion that is a good thing that there are so many different suppliers in the same environment, and that it results in a "healthy competition." I must admit I've never seen it. If we accept that working software is threatening in some way to *everybody* who is involved in the process of developing it - as we discussed earlier, it's easy to see that if everybody involved in the process is working for different organisations, organisations that might lose their contracts if they get the blame for something going wrong, something that comes to light as a result of the inspection of working software, it soon becomes in *everyone's* interested for there to be no working software. This situation is especially bad if the threat is towards either the product owners or senior stakeholders. 

Let's say that the senior stakeholders - the leaders (sociopaths) have overstated the value and understated the cost and time of a project to other senior people in the organisation. By demonstrating what can be made to work within a given timeframe, agile process is probably going to make it clear relatively quickly that these benefits won't be achieved for a particular cost, within a particular time.

Obviously this is a threat to the leaders (sociopaths) who indicated that the benefits would be larger and the timeframes shorter. In such situations, the temptation to set the different suppliers against each other, to threaten that one supplier will be replace by one of the other suppliers unless they "pull their socks up". Is huge.

What's perhaps not really understood about such situations is that they're not actually that threatening to the suppliers, in terms of the amount of business that is directed their way. It's relatively easy for any organisation to absorb the blame (it's very rare that taking the blame has to result in anything like a company or an individual being removed from a project) and promise that they will do better next time.  What is very difficult is for this kind of "blame dispersal mechanism" to operate alongside a focus on working software. In fact this kind of "blame theatre" is essentially a message from the leaders (sociopaths) to the suppliers saying "never embarrass me with working software, or realist projections of costs and timescales again." Nobody needs telling twice. Everybody agrees to avoid producing working software. Everybody gets paid. Nothing gets delivered.
 
##Blitzkrieg Guerrilla
Because in large organisations it is so difficult to get working software "out there" in the wild, in live, and because the importance of having a role that manages the entire pipeline and makes sure that working software is produced is yet to be recognized as important, it might be necessary to take an alternative approach. If you're the leader of a development team, you might want to try to get *just* the software of your development team through to live and then present other teams with a fait accompli.

Towards the end of the first world war, the German army started to develop tactics that avoided trench warfare and instead involved teams moving as fast as they could towards targets without coordination. Because the whole of the German army was, by that point in terrible trouble, these tactics, although they were successful, went mostly unnoticed.  But at the beginning of the second world war, these tactics were spectacularly successful, leading to a German victory over the French in a remarkably short space of time.

Blitzkrieg challenges one of the most fundamental principles of warfare - that all parts of the front should move at once - synchronization.

##Destructive Feedback
When people talk about Agile, they sometimes talk about the importance of the empirical process, and they talk about the three pillars of the empirical process - transparency, inspection and adaptation.  Very often when people talk about empirical process they will end up waving their arms about and indicating the importance of iteration and feedback.

In general, it's agreed that feedback is a very good thing and that complex cognitive tasks can't be achieved without out it.  But there seems to be an aspect of feedback that isn't adequately discussed - that is, situations in which feedback isn't constructive, but is *destructive*.

It's relatively easy to come up with an example. Almost everybody has experienced the unpleasant sound of their own voice being echoed back to them  with a slight delay on a long distance phone call.  If you've done any public speaking at all, you'll know that a space that has a profound echo can be really off-putting, but that some spaces can have a very satisfying resonance.

Imagine that it cost you £10,000 every time you opened your mouth. This isn't dissimilar to the set up with a lot of product owners (except the exact figure, if we counted in all the costs is probably higher).  When you first open your mouth, the feedback you get is terrible. The aspects of what you're saying that you think are *obvious* don't get picked up on at all, the aspects that you think are obscure and difficult are treated as if they're obvious and you're being condescending even to mention them.

There are other ways that feedback can be destructive. Imagine if, as the words were coming out of your mouth, somebody was yelling at you that they were a stupid idea. Would that be good?

You could think that what you're trying to create with a development team and its product owner is a "pleasing echo chamber" for the product owner. But most definitely can't be one that's instantly and brutally critical, nor one that is unthinkingly supportive and enthusiastic.

In this way, maybe the echo chamber of a development team, or the echo change of an Agile programme has to be similar to that other instrument of power - the royal court.

##What Would a Solution Look Like?
>"there are more contexts than the one that we're in - the one that we think is reality." *Alan C. Kay*

This book has been mainly my attempt to create *insights* about the whole emotional business of developing software, to provide alternative ways of seeing what is going on in software development, in the language of Alan C. Kay, alternative contexts.

I suppose the insight that I'm claiming is that software development is an interminable battle between a sociopaths, visionaries and leaders on one side and losers, workers and technologists on the other. It is also a battle between herrenmoral, which values ends and sklaven morral which values means. It's also a battle between beautiful dreams (that can never actual deliver) and ugly reality (which sometimes might).  Possibly it's also a battle between the logic of the unconscious, where, literally, nothing is impossible, and the logic of physics, where even the things that are possible, cost more than you expect and take longer than you want and still have performance problems.  

The battle is interminable because without the attractive dreams of the sociopaths, nothing would get started, and funded and without the actual practical know-how of the loser, worker, technologists, nothing would ever actually get made.
 
Those are the insights of this book.

But insights aren't solutions. I'm not so naive as to think that that there any straight-forward solutions. But I think there might be a path towards solutions from insights - from seeing the world of developing working software from a different point of view - or from several differ points of view. Perhaps by seeing the problem of software development from a different point of view, by thinking about it seriously from this different point of view, we might be able to spy *possible* solutions. That in itself wouldn't be enough.  It wouldn't be enough to understand a solution, we would then have to implement that solution, we would have to *act* differently than we are currently in software development projects.

The idea here is that there is a path from problem, insight, to solution, to action which delivers the solution. But is interesting to reflect that the Agile methodologies that have had the most uptake - Scrum, XP, Kanban don't fill in all the blanks from problem to solution. They just pretty much say "Do this." And leave it to the imagination of the poor benighted organisation or team, who's thinking of using these methods, to imagine that it will solve all the problems that they have with software development.

Maybe there's a two by two matrix. With a y axis that goes from low risk/cost to high/risk cost (this is to the organisation) and an x axis that goes low value, high value (again to the organisation). Practices like focusing on working software, responding to change, collaboration between the customer and focusing on co-location and communication (all four of the Agile values) push projects from top-left to bottom right (or bottom left).

##Blitz Code - never mind 11...

Blitz Code is inspired by the concept (although not the ethics, nor the politics) of the Blitzkrieg strategies exhibited by the German army at the beginning of the second world war. Blitzkrieg was about using a technological advance which had been around for 20 years - the tank - in the way that it should be used to maximum effect. I believe that software development has something similar to the tank in its midst - the DevOps-enable XP Scrum team - the DXST. Extreme programming has always advocated a set of engineering practices.

###Blitz Code's Sine Qua Non(s)
There are some things that absolutely have to be in place before it's even worth thinking about starting development with a Blitz Code team.
####A Product Owner Pair (POP)
Scrum advocates a product owner a single representative of the organisation who is empowered to make decisions about what goes in the product. But most people who've worked with a product owner know that it's almost impossible to find all the skills that are needed by a product owner in one person. There are at least four different sets of skills that are required by a product owner: domain knowledge, knowledge of the organisation, knowledge of technology and knowledge of Agile. Most Scrum projects, if they're *lucky* will get a product owner with knowledge of one of the first two - either a subject matter expert, or someone who had knowledge of the organisation.
####The Product Owner Pair sits with the team
We've got a communication problem. That's one way of thinking of software development - it's a series of communication problems. Scrum (and Blitz Code's) solution to the communication problem is to put everybody within overhearing distance of each other.
####The team have access to a like (or like live environment)
####The team have access to whatever software, hardware and virtual and physical environments that they need
It's embarrassing to have to mention this.  But unfortunately, it still needs mentioning.  If you want a high performance software development team, they should be able to put white boards on every surface that they think should have a whiteboard. If you want a high performance software development team, they should have network access (as one UI Developers was forced to explain it on one project I worked one "to make internetz, need internetz").

They also need computers, a kitchen and a functioning toilet (don't ask).
####There is an owner of DevOps, UI and Non-functional testing in the team

